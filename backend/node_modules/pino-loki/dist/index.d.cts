import * as node_stream0 from "node:stream";
import abstractTransportBuild from "pino-abstract-transport";
import { LogDescriptor } from "pino";

//#region src/constants.d.ts
declare const LokiLogLevel: {
  readonly Info: "info";
  readonly Debug: "debug";
  readonly Error: "error";
  readonly Warning: "warning";
  readonly Critical: "critical";
};
type LokiLogLevel = (typeof LokiLogLevel)[keyof typeof LokiLogLevel];
//#endregion
//#region src/types.d.ts

interface PinoLog {
  level: number;
  msg?: string;
  [key: string]: any;
}
interface BatchingOptions {
  interval?: number;
  maxBufferSize?: number;
}
interface LokiOptions {
  host: string;
  endpoint?: string;
  timeout?: number;
  silenceErrors?: boolean;
  batching?: false | BatchingOptions;
  replaceTimestamp?: boolean;
  labels?: {
    [key: string]: string;
  };
  levelMap?: {
    [key: number]: LokiLogLevel;
  };
  basicAuth?: {
    username: string;
    password: string;
  };
  headers?: Record<string, string>;
  propsToLabels?: string[];
  convertArrays?: boolean;
  structuredMetaKey?: string | false;
  logFormat?: LogFormat;
}
type LogFormatExpectedObject = LogDescriptor & {
  lokilevel: LokiLogLevel;
  time: number;
  level: number;
  msg?: string;
  [key: string]: any;
};
type LogFormat = false | string | ((log: LogFormatExpectedObject) => string);
//#endregion
//#region src/index.d.ts
declare function pinoLoki(userOptions: LokiOptions): node_stream0.Transform & abstractTransportBuild.OnUnknown;
//#endregion
export { type BatchingOptions, LokiLogLevel, type LokiOptions, type PinoLog, pinoLoki as default, pinoLoki };
//# sourceMappingURL=index.d.cts.map